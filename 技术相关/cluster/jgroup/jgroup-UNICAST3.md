# UNICAST3 协议
+ UNICAST让发送方重新发送消息，直到它们被接收方激活为止; UNICAST2让接收方仅在检测到丢失的消息时才要求发送方进行重传，并且从接收方到发送方有周期性的稳定消息，因此发送方可以删除接收方接收的消息。

+ 一旦收到消息，发送者就会删除消息，从而保持内存需求低
+ 丢弃第一个或最后一个消息的问题 [1] [2] 
+ 从接收者到发送者的很多ack
+ 如果ack被删除或被延迟，发送者无需重新发送消息

+ UNICAST2的特点是
    + 没有不需要的ack流量
    + 比UNICAST更快
    + 丢弃第一个或最后一个消息的问题 [1] [2]
    + 实际上，在大量流量上，稳定的消息就足够了
    
+ 两者的缺点是
    +  并发创建/删除连接的问题[3]
    +  关闭连接时，不会刷新挂起的消息[4]

+ UNICAST3旨在保持UNICAST和UNICAST2的积极特征，同时修复负面特征。, 这应该
    + 提供正确的连接管理（使用显式连接建立和拆卸阶段）
    + 通过在关闭连接之前刷新挂起的消息来防止同一连接上的并发关闭和消息发送问题
    + 通过快速清除接收方收到的消息来降低发送方的内存要求
    + 减少基于ack的流量
    + 提供选择性重传（从接收方到发送方的请求）

+ UNICAST3更接近UNICAST，因为它可以回溯到ack 的元信息。

+ 设计
    + 发送者A将单调递增的序列号（seqnos）附加到发送给接收者B的消息
    + 在收到来自A的消息M.B回复M
    + ack在处理单个消息或批量消息结束时发送。 如果收到一批消息A [20-50]，则只有一个ack（50）将被发送到A.
    + Acks是累积的：如果A从B收到ack（50），那么它可以删除seqnos <= 50的所有消息。
    + Acks被推迟, 连续的ack之间有一个最短的时间。
    + 如果B在1秒的过程中将消息5,8,13,52,62,83和101发送给A（最小时间是500ms）
    + 那么也许实际上只会将ack（52）和ack（101）发送给A，然后放弃其他的acks
    + 这减少了发送的ack数量。Ack发送可以通过接收器处的重传任务来完成。
    + 发送端保有最高的ack回应(HA)和最高的seqno相应序列(HS)它有一个定期运行的重新传输任务(500ms)对于所有连接的节点。
    + 如果HA的HA小于HS和且HA / HS组合与前一次运行中读取的组合相同，则A将重新发送最高发送消息M至B, 假设HA = 45且HS = 50。这意味着向B发送了最多50条消息，但到目前为止B只有45条消息。 错过了来自B的46-50 ack。
    + 重传任务将（在第二次迭代中）现在将消息50重新发送到B.B接收50并将其添加到其重传表中。
    + B自己的重传任务与UNICAST2完全相同：它扫描所有接收器窗口并要求发送者重新发送丢失的消息。说B缺少来自A的消息46和48。一旦收到50，它将要求A重传消息46和48。A然后发送46和47，允许B从A中删除消息46-50，并将ack（50）发送回A.现在HA = 50且HS = 50，因此重发任务不会重发任何消息。
    + 总之，UNICAST3将快速确认消息，允许发送者从内存中删除它们，因为每个消息或消息批处理都已被激活。,但是，延迟执行确保在后续的ack之间有一个最短的时间，从而减少ack流量。
    + 在消息被激活之前有一个保证的最长时间（除非确认丢失）并且在发送者重新发送消息之前还有保证的最长时间。

+ 连接建立
    + 将状态OPEN，CLOSING和CLOSED添加到连接条目（SenderEntry，ReceiverEntry），而不是直接建立连接和拆除连接。
    + 当连接关闭时，它不会立即被删除，但其状态将设置为CLOSING。 重发器将在此状态下刷新发件人条目中的未包装消息。 几分钟后没有活动，状态将设置为CLOSED并删除条目。这也是由重传任务完成的。
    + CLOSING和设置CLOSED连接（并将其删除）之间的时间延迟的优点是，当在CLOSING连接上发送消息时，它将再次恢复为OPEN。 如果在时间延迟期间没有发送消息，则可能不再使用连接并且可以安全地删除。时间延迟是可配置的（conn_expiry_timeout）。
    
    + 设计如下
        + 发送方：关闭发件人连接条目
            + 状态设置为CLOSING  
            + 如果HA <HS，重传任务将继续重传

        + 发送方
            + 如果状态为CLOSING：将其设置为OPEN，则重置时间戳
            + 如果状态为CLOSED（应该几乎不会发生，并且条目应该在几毫秒（最大值）之后删除）
            + 转到循环的顶部并再次获取发件人条目（或创建新的连接条目）
            + 实际上，这没有实现，因为它是一个边缘情况并且必须使用锁定会增加复杂性
        + 接收方 接收CLOSE消息（conn-id必须相同）
            + 将接收者条目的状态（如果找到）设置为CLOSED  
            + 删除接收者条目
            + 接收消息
                + 除了null消息，检查CLOSED连接消息（计数与null消息相同）
                + 如果有一个消息批处理，检查是否有一个带有first == true的消息。如果是这样，首先添加该消息，然后将其余消息添加为表格中的大量插入。 否则通过大量插入插入所有消息。
            + 发送SEND_FIRST_SEQNO消息
            + 不会立即发送此消息，而是在接收器条目中设置一个标志
            + 当重新传输任务启动时，它会清除该标志并发送SEND_FIRST_SEQNO消息
            + 收到此消息后，发送方仅发送第一条消息; 其余的将由发送方重新发送，或者接收方将要求重新发送

        + 接收方和发送方 重传任务
            + 如果状态为OPEN且条目已过期且启用了连接收获（conn-expiry-timeout> 0）则
            + 更新时间戳
            + 将状态设置为CLOSING
            如果条目的状态为CLOSING且conn-close-timeout已过期  则
            + 将状态设置为CLOSED并从send-table中删除条目
            + 如果是发送方则向目标目的地发送CLOSE消息

            
+ [1] https://issues.jboss.org/browse/JGRP-1563
+ [2] https://issues.jboss.org/browse/JGRP-1548
+ [3] https://issues.jboss.org/browse/JGRP-1577
+ [4] https://issues.jboss.org/browse/JGRP-1586